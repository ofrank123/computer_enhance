const std = @import("std");
const print = std.debug.print;
const win = std.os.windows;

const NUM_TIMER_SLOTS = 64;
const MAX_STACK_DEPTH = 4096;

const TimerSlot = struct {
    total_time: u64,
    children_time: u64,
    hits: u64,

    name: []const u8,
    is_func: bool,
};

pub const TimerFrame = struct {
    start_time: u64,
    index: u16,
    name: []const u8,
    is_func: bool,
};

const PerfTimerState = struct {
    var cpu_timer_frequency: f64 = 0.0;
    var global_start: u64 = undefined;
    var timer_slots = [_]TimerSlot{TimerSlot{
        .total_time = 0,
        .children_time = 0,
        .hits = 0,
        .name = "",
        .is_func = false,
    }} ** NUM_TIMER_SLOTS;

    var callstack = [_]u16{0} ** MAX_STACK_DEPTH;
    var callstack_depth: u16 = 1;

    var next_slot: u16 = 1;
};

const TimerOptions = struct {
    calibration_millis: u64 = 10,
};

fn getCpuTime() u64 {
    var lo: u64 = undefined;
    var hi: u64 = undefined;

    asm volatile ("rdtsc"
        : [lo] "={eax}" (lo),
          [hi] "={edx}" (hi),
    );

    return (hi << 32) | lo;
}

pub fn calibrateTimer(calibrationMilliseconds: u64) void {
    const os_timer_frequency = win.QueryPerformanceFrequency();
    const calibration_time = os_timer_frequency * calibrationMilliseconds / 1000;

    const cpu_start_time = getCpuTime();
    const os_start_time = win.QueryPerformanceCounter();
    var os_end_time: u64 = 0;
    var os_elapsed: u64 = 0;

    while (os_elapsed < calibration_time) {
        os_end_time = win.QueryPerformanceCounter();
        os_elapsed = os_end_time - os_start_time;
    }

    const cpu_time = @subWithOverflow(getCpuTime(), cpu_start_time)[0];
    const os_time = @subWithOverflow(win.QueryPerformanceCounter(), os_start_time)[0];

    PerfTimerState.cpu_timer_frequency = @floatFromInt(cpu_time * os_timer_frequency / os_time);
}

pub fn resetTimers(options: TimerOptions) void {
    if (@abs(PerfTimerState.cpu_timer_frequency) < std.math.floatEps(f64)) {
        calibrateTimer(options.calibration_millis);
    }

    PerfTimerState.timer_slots = [_]TimerSlot{TimerSlot{
        .total_time = 0,
        .children_time = 0,
        .hits = 0,
        .name = "",
        .is_func = false,
    }} ** NUM_TIMER_SLOTS;
    PerfTimerState.next_slot = 1;
    PerfTimerState.global_start = getCpuTime();
}

pub fn timeFunction(comptime src_location: std.builtin.SourceLocation) TimerFrame {
    const name = comptime n: {
        const file = src_location.file;
        const ext_index = std.mem.lastIndexOfScalar(u8, file, '.') orelse file.len;

        break :n file[0..ext_index] ++ "." ++ src_location.fn_name;
    };
    return timeBlock_internal(name, true);
}

pub fn timeBlock(comptime name: []const u8) TimerFrame {
    return timeBlock_internal(name, false);
}

fn timeBlock_internal(comptime name: []const u8, is_func: bool) TimerFrame {

    //- HACK(ojf): soooooo.... yeah..........
    //
    //
    // you're probably wondering what on god's green earth is going on here.
    // basically, we need to have a unique index for each name.  so we're
    // using a normal local static var, but the way zig's semantics work,
    // each local static is tied to the permutations that are generated by
    // each potential comptime value (as long as that value is used in a
    // given block).  so for each unique "name" we get a new local static.
    // this is some extreme magic, but i found it on discord from one of
    // the lang creators, so i feel a bit safer (cope).  HOWEVER!  if
    // this profiler ever breaks because of a language update, i am almost
    // 100% sure that this function will be the problem.
    //
    // n.b. i should just say that the only reason i feel comfortable using
    // something so arcane is that it is very very important that profiling
    // is super easy as an end user, and has minimal runtime overhead.
    // unfortunately, I can't see this code should not be touched much
    // once it's written.

    const name_value = name[0..].*;

    //- ojf: each call to this function with a unique 'name' gets its own
    // instance of this puppy
    const fucked_idx = comptime &struct {
        //- ojf: force this block to be unique each time there's a new name
        comptime {
            _ = name_value;
        }
        var idx: u16 = 0;
    }.idx;

    //- ojf: if it's 0, we know that this is a unique invocation of the function
    if (fucked_idx.* == 0) {
        std.debug.assert(PerfTimerState.next_slot < PerfTimerState.timer_slots.len);
        fucked_idx.* = PerfTimerState.next_slot;
        PerfTimerState.next_slot += 1;
    }

    const index = fucked_idx.*;

    PerfTimerState.callstack[PerfTimerState.callstack_depth] = index;
    PerfTimerState.callstack_depth += 1;

    return TimerFrame{
        .start_time = getCpuTime(),
        .index = index,
        .name = name,
        .is_func = is_func,
    };
}

///- ojf: old function to check hack overhead
fn timeBlock_internal_old(comptime name: []const u8, is_func: bool) u16 {
    const index = PerfTimerState.next_slot;

    PerfTimerState.timer_slots[index].name = name;
    PerfTimerState.timer_slots[index].end_time = 0;
    PerfTimerState.timer_slots[index].start_time = getCpuTime();
    PerfTimerState.timer_slots[index].is_func = is_func;

    return index;
}

pub fn stopTimer(frame: TimerFrame) void {
    PerfTimerState.callstack_depth -= 1;

    const end_time = getCpuTime();

    const index = frame.index;
    const total_time = @subWithOverflow(end_time, frame.start_time)[0];
    PerfTimerState.timer_slots[index].name = frame.name;
    PerfTimerState.timer_slots[index].is_func = frame.is_func;
    PerfTimerState.timer_slots[index].total_time += total_time;
    PerfTimerState.timer_slots[index].hits += 1;

    const parent_index = PerfTimerState.callstack[PerfTimerState.callstack_depth - 1];
    PerfTimerState.timer_slots[parent_index].children_time += total_time;
}

fn printTimerResults(name: []const u8, is_func: bool, hits: u64, clocks: f64, percent: f64) void {
    const main_fmt = "    hits: {d: <10.0} clocks: {d: <20.0} seconds: {d: <20.6} ({d:.3}%)\n";
    if (is_func) {
        print("{s: >18}():" ++ main_fmt, .{
            name,
            hits,
            clocks,
            clocks / PerfTimerState.cpu_timer_frequency,
            100 * percent,
        });
    } else {
        print("{s: >20}:" ++ main_fmt, .{
            name,
            hits,
            clocks,
            clocks / PerfTimerState.cpu_timer_frequency,
            100 * percent,
        });
    }
}

pub fn stopTimersAndLog() void {
    const global_end = getCpuTime();
    const total_time: f64 = @floatFromInt(@subWithOverflow(
        global_end,
        PerfTimerState.global_start,
    )[0]);

    print("Total Time: {d:.3} seconds\n", .{total_time / PerfTimerState.cpu_timer_frequency});
    for (1..PerfTimerState.next_slot) |timer_index| {
        const slot: *TimerSlot = &PerfTimerState.timer_slots[timer_index];
        const time_elapsed: f64 = @floatFromInt(slot.total_time - slot.children_time);
        const percentage = time_elapsed / total_time;

        printTimerResults(slot.name, slot.is_func, slot.hits, time_elapsed, percentage);
    }
}
